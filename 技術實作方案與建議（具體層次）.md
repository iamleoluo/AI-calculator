# 📋 報告二：技術實作方案與建議（具體層次）

---

## 一、整體技術架構

### 1.1 技術棧選擇

```yaml
前端:
  框架: Next.js 14+ (React 18+)
  語言: TypeScript
  UI 框架: Tailwind CSS + shadcn/ui
  數學渲染: KaTeX
  圖表: Plotly.js
  狀態管理: Zustand
  HTTP 客戶端: TanStack Query (React Query)

後端:
  框架: FastAPI (Python 3.11+)
  AI SDK: Anthropic Python SDK
  數值計算: NumPy, SciPy, SymPy
  API 文件: FastAPI 自動生成
  驗證: Pydantic

資料庫:
  主資料庫: PostgreSQL 15+
  快取: Redis 7+
  
部署:
  前端: Vercel
  後端: Railway / Render / AWS ECS
  資料庫: Supabase / AWS RDS
```

**為什麼這樣選擇？**
- Next.js: 前後端分離，SSR 優化，部署簡單
- FastAPI: 異步支援，自動文件生成，類型安全
- Anthropic: Claude 的數學能力強，適合教學
- PostgreSQL: 關聯式資料庫，適合結構化數據

---

## 二、專案結構

### 2.1 前端結構

```
frontend/
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── page.tsx           # 首頁
│   │   ├── demo/              # AI 示範模式
│   │   ├── practice/          # 學生練習模式
│   │   └── api/               # API Routes (選用)
│   │
│   ├── components/
│   │   ├── ui/                # shadcn/ui 基礎組件
│   │   ├── latex-editor/      # LaTeX 編輯器
│   │   │   ├── Editor.tsx
│   │   │   └── Preview.tsx
│   │   ├── thinking-display/  # AI 思考過程展示
│   │   │   ├── StepCard.tsx
│   │   │   ├── FormulaDisplay.tsx
│   │   │   └── StepNavigation.tsx
│   │   ├── code-display/      # 程式碼展示
│   │   │   └── SyntaxHighlight.tsx
│   │   ├── visualization/     # 視覺化組件
│   │   │   ├── PlotlyChart.tsx
│   │   │   └── ComparisonView.tsx
│   │   └── feedback/          # 反饋面板
│   │       └── FeedbackPanel.tsx
│   │
│   ├── lib/
│   │   ├── api/               # API 客戶端
│   │   │   ├── client.ts
│   │   │   └── endpoints.ts
│   │   └── utils/
│   │       ├── latex-parser.ts
│   │       └── format.ts
│   │
│   ├── stores/                # Zustand stores
│   │   ├── problem-store.ts
│   │   └── ui-store.ts
│   │
│   └── types/                 # TypeScript 類型定義
│       ├── api.ts
│       └── domain.ts
│
├── public/
│   └── images/
│
└── package.json
```

### 2.2 後端結構

```
backend/
├── app/
│   ├── main.py                # FastAPI app entry
│   │
│   ├── api/                   # API Routes
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── derivation.py  # AI 推導相關
│   │   │   ├── verification.py# 驗證相關
│   │   │   └── student.py     # 學生互動相關
│   │   └── deps.py            # 依賴注入
│   │
│   ├── core/                  # 核心業務邏輯
│   │   ├── ai_engine.py       # AI 引擎
│   │   ├── verification.py    # 驗證引擎
│   │   ├── executor.py        # 程式碼執行器
│   │   └── config.py          # 配置
│   │
│   ├── services/              # 業務服務
│   │   ├── fourier_service.py # 傅立葉級數服務
│   │   ├── prompt_builder.py  # Prompt 建構器
│   │   └── error_analyzer.py  # 誤差分析器
│   │
│   ├── models/                # 資料模型
│   │   ├── problem.py
│   │   ├── solution.py
│   │   └── verification.py
│   │
│   ├── schemas/               # Pydantic schemas
│   │   ├── request.py
│   │   └── response.py
│   │
│   └── utils/
│       ├── math_utils.py
│       └── security.py        # 安全執行沙箱
│
├── tests/
│   ├── test_ai_engine.py
│   └── test_verification.py
│
├── requirements.txt
└── .env.example
```

---

## 三、核心模組實作建議

### 3.1 Prompt Builder（Prompt 建構器）

**檔案：** `backend/app/services/prompt_builder.py`

**職責：**
- 構建發送給 Claude 的 Prompt
- 確保格式要求清晰
- 處理迭代時的錯誤反饋

**關鍵方法：**

```python
class PromptBuilder:
    def build_initial_prompt(
        self,
        latex_input: str,
        period: float,
        n_terms: int
    ) -> str:
        """構建初始 Prompt"""
        
    def build_feedback_prompt(
        self,
        latex_input: str,
        previous_response: dict,
        error_report: dict
    ) -> str:
        """構建反饋 Prompt（迭代時使用）"""
        
    def _get_output_format_spec(self) -> str:
        """獲取輸出格式規範"""
        
    def _get_few_shot_examples(self) -> str:
        """獲取 Few-shot 範例"""
```

**Prompt 模板結構：**

```python
INITIAL_PROMPT_TEMPLATE = """
你是數學教授和程式專家。請分析傅立葉級數問題。

【輸入】
函數: {latex_input}
週期: {period}
計算項數: {n_terms}

【輸出要求】
必須返回嚴格的 JSON 格式：

{{
  "thinking_process": {{
    "steps": [
      {{
        "step_number": 1,
        "title": "步驟標題",
        "reasoning": "推理過程",
        "formula_latex": "LaTeX 公式",
        "calculation_steps": ["步驟1", "步驟2"],
        "result": {{"value": 0.0, "latex": "結果 LaTeX"}}
      }}
    ]
  }},
  "executable_code": {{
    "imports": ["numpy as np", "scipy.integrate as integrate"],
    "function_original": "def f(t): return np.sin(t)",
    "function_reconstructed": "def f_fourier(t, coeffs): ...",
    "coefficients": {{
      "a0": 0.0,
      "an": [0.0, 0.0, ...],
      "bn": [1.0, 0.0, ...]
    }}
  }},
  "final_result": {{
    "latex": "f(t) = ..."
  }}
}}

【關鍵約束 - executable_code 部分】
⚠️ 這部分必須極度嚴格 ⚠️
1. function_original 必須是完整可執行的 Python 函數
2. 不要包含 ```python 標記
3. 不要包含註解
4. 確保語法 100% 正確
5. coefficients 必須是純數字（float），不是字串
6. 可以直接用 exec() 執行

【範例】
{few_shot_examples}

現在請處理上述輸入。
"""

FEEDBACK_PROMPT_TEMPLATE = """
上次計算存在誤差，需要重新計算。

【原始問題】
函數: {latex_input}

【上次結果】
你計算的係數: {ai_coefficients}

【驗證結果】
數值方法計算: {numerical_coefficients}
誤差: {error_percentage}%

【問題分析】
{error_analysis}

【建議】
{suggestions}

請重新計算，特別注意：
{specific_focus}

輸出格式同上（必須包含 thinking_process 和 executable_code）。
"""
```

---

### 3.2 AI Engine（AI 引擎）

**檔案：** `backend/app/core/ai_engine.py`

**職責：**
- 呼叫 Claude API
- 解析 AI 返回的 JSON
- 處理格式錯誤
- 重試機制

**關鍵方法：**

```python
class AIEngine:
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.max_retries = 3
        
    async def derive_fourier_series(
        self,
        prompt: str,
        temperature: float = 0.0
    ) -> dict:
        """
        呼叫 Claude API 進行傅立葉級數推導
        返回解析後的 JSON
        """
        
    def _parse_response(self, response: str) -> dict:
        """解析 AI 返回的 JSON"""
        
    def _validate_response(self, data: dict) -> bool:
        """驗證返回的 JSON 格式"""
        
    def _fix_common_errors(self, response: str) -> str:
        """修正常見的格式錯誤"""
```

**呼叫 Claude 的設定：**

```python
response = self.client.messages.create(
    model="claude-sonnet-4-5-20250929",
    max_tokens=8192,  # 足夠長的輸出
    temperature=0.0,   # 確保一致性
    system="你是數學和程式設計專家...",
    messages=[{
        "role": "user",
        "content": prompt
    }]
)
```

---

### 3.3 Code Executor（程式碼執行器）

**檔案：** `backend/app/core/executor.py`

**職責：**
- 安全執行 AI 生成的 Python 程式碼
- 提取函數定義
- 計算數值結果

**安全考量：**

```python
class SafeCodeExecutor:
    def __init__(self):
        # 允許的模組白名單
        self.allowed_modules = {
            'numpy': numpy,
            'np': numpy,
            'scipy.integrate': scipy.integrate,
            'math': math
        }
        
    def execute_function(
        self,
        code: str,
        function_name: str = "f"
    ) -> callable:
        """
        安全執行程式碼並返回函數
        
        Args:
            code: AI 生成的程式碼
            function_name: 要提取的函數名稱
            
        Returns:
            可呼叫的函數對象
        """
        # 建立受限的 namespace
        exec_globals = self.allowed_modules.copy()
        
        try:
            # 執行程式碼
            exec(code, exec_globals)
            
            # 提取函數
            if function_name in exec_globals:
                return exec_globals[function_name]
            else:
                raise ValueError(f"函數 {function_name} 未定義")
                
        except Exception as e:
            raise ExecutionError(f"程式碼執行失敗: {e}")
            
    def compute_coefficients(
        self,
        func: callable,
        period: float,
        n_terms: int
    ) -> dict:
        """
        數值計算傅立葉係數
        """
        omega0 = 2 * np.pi / period
        
        # 計算 a0
        a0, _ = integrate.quad(func, 0, period)
        a0 = (2 / period) * a0
        
        # 計算 an, bn
        an = []
        bn = []
        for n in range(1, n_terms + 1):
            # an 係數
            integrand_an = lambda t: func(t) * np.cos(n * omega0 * t)
            an_val, _ = integrate.quad(integrand_an, 0, period)
            an.append((2 / period) * an_val)
            
            # bn 係數
            integrand_bn = lambda t: func(t) * np.sin(n * omega0 * t)
            bn_val, _ = integrate.quad(integrand_bn, 0, period)
            bn.append((2 / period) * bn_val)
            
        return {
            "a0": float(a0),
            "an": [float(x) for x in an],
            "bn": [float(x) for x in bn]
        }
```

---

### 3.4 Verification Engine（驗證引擎）

**檔案：** `backend/app/core/verification.py`

**職責：**
- 比對 AI 結果與數值計算結果
- 計算誤差指標
- 生成誤差報告

**關鍵方法：**

```python
class VerificationEngine:
    def __init__(self, error_threshold: float = 0.01):
        self.error_threshold = error_threshold
        self.executor = SafeCodeExecutor()
        
    def verify(
        self,
        ai_response: dict,
        latex_input: str,
        period: float,
        n_terms: int
    ) -> dict:
        """
        完整的驗證流程
        
        Returns:
            {
                "is_verified": bool,
                "error_metrics": dict,
                "error_report": dict,
                "numerical_result": dict
            }
        """
        
    def _compare_coefficients(
        self,
        ai_coeffs: dict,
        numerical_coeffs: dict
    ) -> dict:
        """
        比對係數並計算誤差
        
        Returns:
            {
                "a0_error": float,
                "an_errors": List[float],
                "bn_errors": List[float],
                "max_error": float,
                "relative_error": float
            }
        """
        
    def _generate_error_report(
        self,
        errors: dict,
        ai_coeffs: dict,
        numerical_coeffs: dict
    ) -> dict:
        """
        生成詳細的誤差報告
        
        Returns:
            {
                "summary": str,
                "details": List[str],
                "suggestions": List[str],
                "problematic_terms": List[int]
            }
        """
```

**誤差計算邏輯：**

```python
def calculate_relative_error(ai_value, numerical_value):
    """計算相對誤差"""
    if abs(numerical_value) < 1e-10:
        # 接近零，使用絕對誤差
        return abs(ai_value - numerical_value)
    else:
        return abs(ai_value - numerical_value) / abs(numerical_value)

# 對所有係數計算誤差
max_error = max([
    calculate_relative_error(ai_coeffs['a0'], num_coeffs['a0']),
    max([calculate_relative_error(a_ai, a_num) 
         for a_ai, a_num in zip(ai_coeffs['an'], num_coeffs['an'])]),
    max([calculate_relative_error(b_ai, b_num) 
         for b_ai, b_num in zip(ai_coeffs['bn'], num_coeffs['bn'])])
])
```

---

### 3.5 Fourier Service（主要業務邏輯）

**檔案：** `backend/app/services/fourier_service.py`

**職責：**
- 協調整個計算流程
- 實現迭代機制
- 管理狀態

**主要流程：**

```python
class FourierSeriesService:
    def __init__(self):
        self.ai_engine = AIEngine(api_key=settings.CLAUDE_API_KEY)
        self.prompt_builder = PromptBuilder()
        self.verification = VerificationEngine()
        self.max_iterations = 5
        
    async def compute_with_verification(
        self,
        latex_input: str,
        period: float,
        n_terms: int
    ) -> dict:
        """
        完整的計算與驗證流程
        
        Returns:
            {
                "success": bool,
                "iterations": int,
                "final_result": dict,
                "verification": dict,
                "history": List[dict]
            }
        """
        history = []
        
        for iteration in range(self.max_iterations):
            # 1. 構建 Prompt
            if iteration == 0:
                prompt = self.prompt_builder.build_initial_prompt(
                    latex_input, period, n_terms
                )
            else:
                prompt = self.prompt_builder.build_feedback_prompt(
                    latex_input, 
                    previous_response,
                    error_report
                )
            
            # 2. 呼叫 AI
            ai_response = await self.ai_engine.derive_fourier_series(prompt)
            
            # 3. 驗證
            verification_result = self.verification.verify(
                ai_response, latex_input, period, n_terms
            )
            
            # 4. 記錄歷史
            history.append({
                "iteration": iteration + 1,
                "ai_response": ai_response,
                "verification": verification_result
            })
            
            # 5. 判斷是否通過
            if verification_result["is_verified"]:
                return {
                    "success": True,
                    "iterations": iteration + 1,
                    "final_result": ai_response,
                    "verification": verification_result,
                    "history": history
                }
            
            # 6. 準備下一次迭代
            previous_response = ai_response
            error_report = verification_result["error_report"]
        
        # 達到最大迭代次數仍未通過
        return {
            "success": False,
            "iterations": self.max_iterations,
            "final_result": ai_response,
            "verification": verification_result,
            "history": history,
            "error": "達到最大迭代次數，仍無法達到精確度要求"
        }
```

---

## 四、API 設計

### 4.1 主要 API 端點

**檔案：** `backend/app/api/v1/derivation.py`

```python
from fastapi import APIRouter, HTTPException
from app.schemas.request import FourierRequest
from app.schemas.response import FourierResponse
from app.services.fourier_service import FourierSeriesService

router = APIRouter()
service = FourierSeriesService()

@router.post("/fourier-series", response_model=FourierResponse)
async def compute_fourier_series(request: FourierRequest):
    """
    計算傅立葉級數
    
    Request Body:
        - latex_input: str (LaTeX 格式的函數)
        - period: float (週期)
        - n_terms: int (計算項數)
        
    Response:
        - thinking_process: 推導過程（給前端展示）
        - code_display: 程式碼（給前端展示）
        - final_result: 最終 LaTeX 公式
        - verification: 驗證結果
        - visualization_data: 圖表數據
    """
    try:
        result = await service.compute_with_verification(
            request.latex_input,
            request.period,
            request.n_terms
        )
        
        if not result["success"]:
            raise HTTPException(status_code=422, detail=result["error"])
        
        # 組裝返回給前端的數據
        return FourierResponse(
            thinking_process=result["final_result"]["thinking_process"],
            code_display=_format_code_for_display(
                result["final_result"]["executable_code"]
            ),
            final_result=result["final_result"]["final_result"],
            verification=result["verification"],
            iterations=result["iterations"],
            history=result["history"]
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### 4.2 Request/Response Schemas

**檔案：** `backend/app/schemas/request.py`

```python
from pydantic import BaseModel, Field

class FourierRequest(BaseModel):
    latex_input: str = Field(..., description="LaTeX 格式的函數")
    period: float = Field(..., gt=0, description="函數週期")
    n_terms: int = Field(..., ge=1, le=20, description="計算項數")
    
    class Config:
        json_schema_extra = {
            "example": {
                "latex_input": "\\sin(t)",
                "period": 6.283185,
                "n_terms": 5
            }
        }
```

**檔案：** `backend/app/schemas/response.py`

```python
from pydantic import BaseModel
from typing import List, Dict, Any

class ThinkingStep(BaseModel):
    step_number: int
    title: str
    reasoning: str
    formula_latex: str
    calculation_steps: List[str]
    result: Dict[str, Any]

class ThinkingProcess(BaseModel):
    steps: List[ThinkingStep]

class VerificationResult(BaseModel):
    is_verified: bool
    error_metrics: Dict[str, float]
    error_report: Dict[str, Any]

class FourierResponse(BaseModel):
    thinking_process: ThinkingProcess
    code_display: str
    final_result: Dict[str, str]
    verification: VerificationResult
    iterations: int
```

---

## 五、資料庫設計

### 5.1 Schema 設計

```sql
-- 問題表
CREATE TABLE problems (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    latex_input TEXT NOT NULL,
    period FLOAT NOT NULL,
    n_terms INTEGER NOT NULL,
    category VARCHAR(50) DEFAULT 'fourier_series',
    created_at TIMESTAMP DEFAULT NOW()
);

-- AI 解答表
CREATE TABLE ai_solutions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    problem_id UUID REFERENCES problems(id),
    thinking_process JSONB NOT NULL,
    executable_code JSONB NOT NULL,
    coefficients JSONB NOT NULL,
    final_latex TEXT NOT NULL,
    iterations INTEGER DEFAULT 1,
    computation_time FLOAT,  -- 秒
    created_at TIMESTAMP DEFAULT NOW()
);

-- 驗證記錄表
CREATE TABLE verifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    solution_id UUID REFERENCES ai_solutions(id),
    is_verified BOOLEAN NOT NULL,
    error_metrics JSONB NOT NULL,
    numerical_result JSONB NOT NULL,
    error_report JSONB,
    verified_at TIMESTAMP DEFAULT NOW()
);

-- 迭代歷史表（用於分析）
CREATE TABLE iteration_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    solution_id UUID REFERENCES ai_solutions(id),
    iteration_number INTEGER NOT NULL,
    ai_response JSONB NOT NULL,
    verification_result JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_problems_category ON problems(category);
CREATE INDEX idx_solutions_problem ON ai_solutions(problem_id);
CREATE INDEX idx_verifications_solution ON verifications(solution_id);
```

---

## 六、前端實作建議

### 6.1 核心組件

**1. Thinking Process Display（推導過程展示）**

```typescript
// components/thinking-display/StepCard.tsx
interface StepCardProps {
  step: ThinkingStep;
  isExpanded: boolean;
  onToggle: () => void;
}

export function StepCard({ step, isExpanded, onToggle }: StepCardProps) {
  return (
    <Card>
      <CardHeader onClick={onToggle}>
        <h3>步驟 {step.step_number}: {step.title}</h3>
      </CardHeader>
      {isExpanded && (
        <CardContent>
          <p>{step.reasoning}</p>
          <MathDisplay latex={step.formula_latex} />
          {step.calculation_steps.map((calc, i) => (
            <MathDisplay key={i} latex={calc} />
          ))}
          <Result>
            <MathDisplay latex={step.result.latex} />
          </Result>
        </CardContent>
      )}
    </Card>
  );
}
```

**2. Visualization Component（視覺化組件）**

```typescript
// components/visualization/ComparisonView.tsx
import Plot from 'react-plotly.js';

interface ComparisonViewProps {
  originalData: number[];
  reconstructedData: number[];
  timePoints: number[];
}

export function ComparisonView({ 
  originalData, 
  reconstructedData, 
  timePoints 
}: ComparisonViewProps) {
  const plotData = [
    {
      x: timePoints,
      y: originalData,
      type: 'scatter',
      mode: 'lines',
      name: '原始函數',
      line: { color: 'blue' }
    },
    {
      x: timePoints,
      y: reconstructedData,
      type: 'scatter',
      mode: 'lines',
      name: '重建函數',
      line: { color: 'red', dash: 'dash' }
    }
  ];
  
  return <Plot data={plotData} layout={{...}} />;
}
```

### 6.2 狀態管理

```typescript
// stores/problem-store.ts
import { create } from 'zustand';

interface ProblemState {
  latexInput: string;
  period: number;
  nTerms: number;
  result: FourierResponse | null;
  isLoading: boolean;
  
  setLatexInput: (input: string) => void;
  setPeriod: (period: number) => void;
  setNTerms: (n: number) => void;
  computeFourierSeries: () => Promise<void>;
}

export const useProblemStore = create<ProblemState>((set, get) => ({
  latexInput: '',
  period: 2 * Math.PI,
  nTerms: 5,
  result: null,
  isLoading: false,
  
  setLatexInput: (input) => set({ latexInput: input }),
  setPeriod: (period) => set({ period }),
  setNTerms: (n) => set({ nTerms: n }),
  
  computeFourierSeries: async () => {
    set({ isLoading: true });
    try {
      const { latexInput, period, nTerms } = get();
      const response = await api.computeFourierSeries({
        latexInput,
        period,
        nTerms
      });
      set({ result: response, isLoading: false });
    } catch (error) {
      set({ isLoading: false });
      // 錯誤處理
    }
  }
}));
```

---

## 七、部署建議

### 7.1 開發環境設置

```bash
# 前端
cd frontend
npm install
npm run dev  # http://localhost:3000

# 後端
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn app.main:app --reload  # http://localhost:8000
```

### 7.2 生產環境部署

**前端（Vercel）：**
```bash
# 連接 GitHub repo
# Vercel 自動檢測 Next.js
# 設定環境變數: NEXT_PUBLIC_API_URL

vercel deploy
```

**後端（Railway）：**
```bash
# 創建 railway.json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "uvicorn app.main:app --host 0.0.0.0 --port $PORT",
    "restartPolicyType": "ON_FAILURE"
  }
}

# 設定環境變數:
CLAUDE_API_KEY=xxx
DATABASE_URL=xxx
REDIS_URL=xxx

# 部署
railway up
```

---

## 八、測試策略

### 8.1 單元測試

```python
# tests/test_verification.py
import pytest
from app.core.verification import VerificationEngine

def test_compare_coefficients_exact_match():
    """測試係數完全匹配"""
    engine = VerificationEngine()
    
    ai_coeffs = {"a0": 0.0, "an": [0.0, 0.0], "bn": [1.0, 0.0]}
    num_coeffs = {"a0": 0.0, "an": [0.0, 0.0], "bn": [1.0, 0.0]}
    
    result = engine._compare_coefficients(ai_coeffs, num_coeffs)
    
    assert result["max_error"] < 1e-10
    assert result["relative_error"] < 1e-10

def test_compare_coefficients_with_error():
    """測試有誤差的情況"""
    engine = VerificationEngine(error_threshold=0.05)
    
    ai_coeffs = {"a0": 0.0, "an": [0.1, 0.0], "bn": [1.0, 0.0]}
    num_coeffs = {"a0": 0.0, "an": [0.0, 0.0], "bn": [1.0, 0.0]}
    
    result = engine._compare_coefficients(ai_coeffs, num_coeffs)
    
    assert result["max_error"] > 0.05
```

### 8.2 整合測試

```python
# tests/test_fourier_service.py
@pytest.mark.asyncio
async def test_full_computation_flow():
    """測試完整的計算流程"""
    service = FourierSeriesService()
    
    result = await service.compute_with_verification(
        latex_input="\\sin(t)",
        period=2 * np.pi,
        n_terms=5
    )
    
    assert result["success"] == True
    assert result["iterations"] <= 5
    assert result["verification"]["is_verified"] == True
```

---

## 九、監控與日誌

### 9.1 日誌設計

```python
import logging
import structlog

# 配置結構化日誌
structlog.configure(
    processors=[
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

logger = structlog.get_logger()

# 使用範例
logger.info(
    "ai_derivation_completed",
    problem_id=problem_id,
    iterations=iterations,
    error=error_percentage,
    computation_time=elapsed_time
)
```

### 9.2 關鍵指標監控

```python
# 需要監控的指標
- AI API 呼叫次數
- 平均響應時間
- 驗證通過率
- 平均迭代次數
- 錯誤率
```

---

## 十、總結與建議

### 10.1 實作優先順序

**Phase 1: 核心功能（2-3週）**
1. Prompt Builder
2. AI Engine
3. Code Executor
4. Verification Engine
5. 基本 API

**Phase 2: 前端開發（2週）**
1. LaTeX 編輯器
2. Thinking Display
3. 視覺化組件
4. API 整合

**Phase 3: 優化與測試（1週）**
1. 誤差迭代優化
2. 單元測試
3. 整合測試

**Phase 4: 部署（1週）**
1. 環境配置
2. CI/CD
3. 監控設置

### 10.2 關鍵注意事項

1. **Prompt 是核心**
   - 花時間測試和優化 Prompt
   - 確保輸出格式穩定
   - Few-shot 範例很重要

2. **安全執行**
   - 永遠不要直接執行未驗證的程式碼
   - 使用沙箱或受限環境
   - 設置超時機制

3. **誤差閾值**
   - 根據實際測試調整閾值
   - 不同函數可能需要不同閾值
   - 記錄誤差分布以便分析

4. **使用者體驗**
   - 提供即時反饋
   - 載入狀態要清楚
   - 錯誤訊息要友善

---

這份報告提供了具體的實作建議，但 Claude Code 可以根據實際情況調整。關鍵是保持核心設計原則：**雙軌輸出** 和 **閉環驗證**。🚀